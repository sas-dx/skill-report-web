# ユニットテスト実装ガイド: 年間スキル報告書WEB化PJT

---

## 1. 文書情報

| 項目 | 内容 |
|------|------|
| 文書名 | ユニットテスト実装ガイド（統合版） |
| プロジェクト名 | 年間スキル報告書WEB化プロジェクト |
| システム名 | スキル報告書管理システム（SRMS） |
| プロジェクトID | SAS-DX-AI-2025-001 |
| 作成者 | AI推進チーム |
| 作成日 | 2025年5月29日 |
| 最終更新日 | 2025年6月2日 |
| 版数 | 2.0 |

---

## 2. テスト環境セットアップ

### 2.1 必要パッケージのインストール

```bash
# テストフレームワーク・ライブラリ
npm install -D vitest @vitest/ui @vitest/coverage-v8

# React テスト関連
npm install -D @testing-library/react @testing-library/jest-dom @testing-library/user-event

# モック・API テスト
npm install -D msw

# 型定義
npm install -D @types/testing-library__jest-dom
```

### 2.2 設定ファイル

#### vitest.config.ts
```typescript
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    setupFiles: ['./src/test/setup.ts'],
    globals: true,
    css: true,
    coverage: {
      provider: 'v8',
      reporter: ['text', 'html', 'lcov', 'json'],
      reportsDirectory: './coverage',
      exclude: [
        'node_modules/',
        'src/test/',
        '**/*.d.ts',
        '**/*.config.*',
        '**/dist/**'
      ],
      threshold: {
        global: {
          branches: 90,
          functions: 90,
          lines: 90,
          statements: 90
        }
      }
    }
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@/components': path.resolve(__dirname, './src/components'),
      '@/services': path.resolve(__dirname, './src/services'),
      '@/utils': path.resolve(__dirname, './src/utils'),
      '@/types': path.resolve(__dirname, './src/types')
    }
  }
})
```

#### src/test/setup.ts
```typescript
import '@testing-library/jest-dom'
import { beforeAll, afterEach, afterAll } from 'vitest'
import { server } from './mocks/server'

// MSW サーバーセットアップ
beforeAll(() => server.listen())
afterEach(() => server.resetHandlers())
afterAll(() => server.close())

// LocalStorage モック
const localStorageMock = {
  getItem: vi.fn(),
  setItem: vi.fn(),
  removeItem: vi.fn(),
  clear: vi.fn(),
  length: 0,
  key: vi.fn()
}

Object.defineProperty(window, 'localStorage', {
  value: localStorageMock
})

// SessionStorage モック
Object.defineProperty(window, 'sessionStorage', {
  value: localStorageMock
})

// matchMedia モック
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: vi.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: vi.fn(),
    removeListener: vi.fn(),
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn(),
  })),
})

// ResizeObserver モック
global.ResizeObserver = vi.fn().mockImplementation(() => ({
  observe: vi.fn(),
  unobserve: vi.fn(),
  disconnect: vi.fn(),
}))

// IntersectionObserver モック
global.IntersectionObserver = vi.fn().mockImplementation(() => ({
  observe: vi.fn(),
  unobserve: vi.fn(),
  disconnect: vi.fn(),
}))
```

#### package.json スクリプト追加
```json
{
  "scripts": {
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:run": "vitest run",
    "test:coverage": "vitest run --coverage",
    "test:watch": "vitest --watch"
  }
}
```

---

## 3. モックサーバー設定（MSW）

### 3.1 MSW ハンドラー設定

#### src/test/mocks/handlers.ts
```typescript
import { rest } from 'msw'

export const handlers = [
  // 認証API
  rest.post('/api/auth/login', (req, res, ctx) => {
    const { email, password } = req.body as { email: string; password: string }
    
    if (email === 'user@example.com' && password === 'password') {
      return res(
        ctx.status(200),
        ctx.json({
          success: true,
          token: 'mock-jwt-token',
          user: {
            id: 1,
            name: 'テストユーザー',
            email: 'user@example.com',
            role: 'user'
          }
        })
      )
    }
    
    return res(
      ctx.status(401),
      ctx.json({
        success: false,
        error: '認証に失敗しました'
      })
    )
  }),

  rest.post('/api/auth/logout', (req, res, ctx) => {
    return res(
      ctx.status(200),
      ctx.json({ success: true })
    )
  }),

  // スキル管理API
  rest.get('/api/skills', (req, res, ctx) => {
    return res(
      ctx.status(200),
      ctx.json([
        {
          id: 1,
          name: 'JavaScript',
          category: 'プログラミング言語',
          level: '○',
          experience: '3年'
        },
        {
          id: 2,
          name: 'TypeScript',
          category: 'プログラミング言語',
          level: '◎',
          experience: '2年'
        }
      ])
    )
  }),

  rest.post('/api/skills', (req, res, ctx) => {
    const skill = req.body as any
    return res(
      ctx.status(201),
      ctx.json({
        id: Date.now(),
        ...skill,
        createdAt: new Date().toISOString()
      })
    )
  }),

  rest.put('/api/skills/:id', (req, res, ctx) => {
    const { id } = req.params
    const skill = req.body as any
    return res(
      ctx.status(200),
      ctx.json({
        id: Number(id),
        ...skill,
        updatedAt: new Date().toISOString()
      })
    )
  }),

  rest.delete('/api/skills/:id', (req, res, ctx) => {
    return res(ctx.status(204))
  }),

  // プロフィール管理API
  rest.get('/api/profile', (req, res, ctx) => {
    return res(
      ctx.status(200),
      ctx.json({
        id: 1,
        name: 'テストユーザー',
        email: 'user@example.com',
        department: '開発部',
        position: 'エンジニア',
        joinDate: '2020-04-01'
      })
    )
  }),

  rest.put('/api/profile', (req, res, ctx) => {
    const profile = req.body as any
    return res(
      ctx.status(200),
      ctx.json({
        ...profile,
        updatedAt: new Date().toISOString()
      })
    )
  })
]
```

#### src/test/mocks/server.ts
```typescript
import { setupServer } from 'msw/node'
import { handlers } from './handlers'

export const server = setupServer(...handlers)
```

---

## 4. ユニットテスト実装例

### 4.1 認証サービステスト

#### src/services/__tests__/AuthService.test.ts
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { AuthService } from '../AuthService'

describe('AuthService', () => {
  let authService: AuthService
  
  beforeEach(() => {
    authService = new AuthService()
    localStorage.clear()
  })

  describe('ログイン機能', () => {
    it('正常系: 有効な認証情報でログイン成功', async () => {
      const result = await authService.login('user@example.com', 'password')
      
      expect(result.success).toBe(true)
      expect(result.token).toBe('mock-jwt-token')
      expect(result.user).toEqual({
        id: 1,
        name: 'テストユーザー',
        email: 'user@example.com',
        role: 'user'
      })
    })

    it('異常系: 無効なパスワードでログイン失敗', async () => {
      const result = await authService.login('user@example.com', 'wrongpassword')
      
      expect(result.success).toBe(false)
      expect(result.error).toBe('認証に失敗しました')
      expect(result.token).toBeUndefined()
    })

    it('境界値: 空文字列での認証', async () => {
      const result = await authService.login('', '')
      
      expect(result.success).toBe(false)
      expect(result.error).toBe('メールアドレスとパスワードは必須です')
    })

    it('境界値: 不正なメールアドレス形式', async () => {
      const result = await authService.login('invalid-email', 'password')
      
      expect(result.success).toBe(false)
      expect(result.error).toBe('有効なメールアドレスを入力してください')
    })
  })

  describe('ログアウト機能', () => {
    it('正常系: ログアウト成功', async () => {
      // 事前にログイン状態にする
      await authService.login('user@example.com', 'password')
      
      const result = await authService.logout()
      
      expect(result.success).toBe(true)
      expect(localStorage.getItem('token')).toBeNull()
    })
  })

  describe('トークン管理', () => {
    it('正常系: トークンの保存・取得', () => {
      const token = 'test-token'
      authService.setToken(token)
      
      expect(authService.getToken()).toBe(token)
      expect(localStorage.setItem).toHaveBeenCalledWith('token', token)
    })

    it('正常系: トークンの削除', () => {
      authService.setToken('test-token')
      authService.removeToken()
      
      expect(authService.getToken()).toBeNull()
      expect(localStorage.removeItem).toHaveBeenCalledWith('token')
    })

    it('正常系: トークンの有効性チェック', () => {
      // 有効なトークン
      const validToken = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjk5OTk5OTk5OTl9.signature'
      expect(authService.isTokenValid(validToken)).toBe(true)
      
      // 無効なトークン
      expect(authService.isTokenValid('invalid-token')).toBe(false)
      expect(authService.isTokenValid('')).toBe(false)
      expect(authService.isTokenValid(null)).toBe(false)
    })
  })
})
```

### 4.2 スキル管理サービステスト

#### src/services/__tests__/SkillService.test.ts
```typescript
import { describe, it, expect, beforeEach } from 'vitest'
import { SkillService } from '../SkillService'
import type { Skill, SkillLevel } from '@/types/skill'

describe('SkillService', () => {
  let skillService: SkillService
  
  beforeEach(() => {
    skillService = new SkillService()
  })

  describe('スキル評価計算', () => {
    it('正常系: 4段階評価（×/△/○/◎）の計算', () => {
      const skills: Skill[] = [
        { id: 1, name: 'JavaScript', level: '×', weight: 1 },
        { id: 2, name: 'TypeScript', level: '△', weight: 2 },
        { id: 3, name: 'React', level: '○', weight: 3 },
        { id: 4, name: 'Node.js', level: '◎', weight: 4 }
      ]
      
      const result = skillService.calculateSkillScore(skills)
      expect(result).toBe(2.5) // (1+2+3+4)/4 = 2.5
    })

    it('異常系: 不正な評価レベル', () => {
      const invalidSkills = [
        { id: 1, name: 'Test', level: 'invalid' as SkillLevel, weight: 1 }
      ]
      
      expect(() => {
        skillService.calculateSkillScore(invalidSkills)
      }).toThrow('Invalid skill level: invalid')
    })

    it('境界値: 空配列', () => {
      const result = skillService.calculateSkillScore([])
      expect(result).toBe(0)
    })

    it('境界値: 単一スキル', () => {
      const skills: Skill[] = [
        { id: 1, name: 'JavaScript', level: '○', weight: 3 }
      ]
      
      const result = skillService.calculateSkillScore(skills)
      expect(result).toBe(3)
    })
  })

  describe('スキルレベル変換', () => {
    it('正常系: レベル文字から数値への変換', () => {
      expect(skillService.levelToNumber('×')).toBe(1)
      expect(skillService.levelToNumber('△')).toBe(2)
      expect(skillService.levelToNumber('○')).toBe(3)
      expect(skillService.levelToNumber('◎')).toBe(4)
    })

    it('正常系: 数値からレベル文字への変換', () => {
      expect(skillService.numberToLevel(1)).toBe('×')
      expect(skillService.numberToLevel(2)).toBe('△')
      expect(skillService.numberToLevel(3)).toBe('○')
      expect(skillService.numberToLevel(4)).toBe('◎')
    })

    it('異常系: 範囲外の数値', () => {
      expect(() => skillService.numberToLevel(0)).toThrow('Invalid level number: 0')
      expect(() => skillService.numberToLevel(5)).toThrow('Invalid level number: 5')
    })
  })

  describe('スキル検索・フィルタリング', () => {
    const mockSkills: Skill[] = [
      { id: 1, name: 'JavaScript', category: 'プログラミング言語', level: '○' },
      { id: 2, name: 'TypeScript', category: 'プログラミング言語', level: '◎' },
      { id: 3, name: 'React', category: 'フレームワーク', level: '○' },
      { id: 4, name: 'Vue.js', category: 'フレームワーク', level: '△' }
    ]

    it('正常系: カテゴリによるフィルタリング', () => {
      const result = skillService.filterByCategory(mockSkills, 'プログラミング言語')
      
      expect(result).toHaveLength(2)
      expect(result.map(s => s.name)).toEqual(['JavaScript', 'TypeScript'])
    })

    it('正常系: レベルによるフィルタリング', () => {
      const result = skillService.filterByLevel(mockSkills, '○')
      
      expect(result).toHaveLength(2)
      expect(result.map(s => s.name)).toEqual(['JavaScript', 'React'])
    })

    it('正常系: 名前による検索', () => {
      const result = skillService.searchByName(mockSkills, 'Script')
      
      expect(result).toHaveLength(2)
      expect(result.map(s => s.name)).toEqual(['JavaScript', 'TypeScript'])
    })

    it('境界値: 該当なしの検索', () => {
      const result = skillService.searchByName(mockSkills, 'Python')
      expect(result).toHaveLength(0)
    })
  })

  describe('API連携テスト', () => {
    it('正常系: スキル一覧取得', async () => {
      const skills = await skillService.getSkills()
      
      expect(skills).toHaveLength(2)
      expect(skills[0]).toEqual({
        id: 1,
        name: 'JavaScript',
        category: 'プログラミング言語',
        level: '○',
        experience: '3年'
      })
    })

    it('正常系: スキル作成', async () => {
      const newSkill = {
        name: 'Python',
        category: 'プログラミング言語',
        level: '△' as SkillLevel
      }
      
      const result = await skillService.createSkill(newSkill)
      
      expect(result.name).toBe('Python')
      expect(result.id).toBeDefined()
      expect(result.createdAt).toBeDefined()
    })

    it('正常系: スキル更新', async () => {
      const updatedSkill = {
        id: 1,
        name: 'JavaScript',
        category: 'プログラミング言語',
        level: '◎' as SkillLevel
      }
      
      const result = await skillService.updateSkill(1, updatedSkill)
      
      expect(result.level).toBe('◎')
      expect(result.updatedAt).toBeDefined()
    })

    it('正常系: スキル削除', async () => {
      const result = await skillService.deleteSkill(1)
      expect(result).toBe(true)
    })
  })
})
```

### 4.3 Reactコンポーネントテスト

#### src/components/__tests__/LoginForm.test.tsx
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { LoginForm } from '../LoginForm'

describe('LoginForm', () => {
  const mockOnSubmit = vi.fn()
  const mockOnError = vi.fn()
  
  beforeEach(() => {
    mockOnSubmit.mockClear()
    mockOnError.mockClear()
  })

  it('正常系: フォームの初期表示', () => {
    render(<LoginForm onSubmit={mockOnSubmit} onError={mockOnError} />)
    
    expect(screen.getByLabelText('メールアドレス')).toBeInTheDocument()
    expect(screen.getByLabelText('パスワード')).toBeInTheDocument()
    expect(screen.getByRole('button', { name: 'ログイン' })).toBeInTheDocument()
  })

  it('正常系: 有効な入力でフォーム送信', async () => {
    const user = userEvent.setup()
    
    render(<LoginForm onSubmit={mockOnSubmit} onError={mockOnError} />)
    
    // 入力
    await user.type(screen.getByLabelText('メールアドレス'), 'user@example.com')
    await user.type(screen.getByLabelText('パスワード'), 'password')
    
    // 送信
    await user.click(screen.getByRole('button', { name: 'ログイン' }))
    
    await waitFor(() => {
      expect(mockOnSubmit).toHaveBeenCalledWith({
        email: 'user@example.com',
        password: 'password'
      })
    })
  })

  it('異常系: 必須項目未入力時のバリデーション', async () => {
    const user = userEvent.setup()
    
    render(<LoginForm onSubmit={mockOnSubmit} onError={mockOnError} />)
    
    // 空のまま送信
    await user.click(screen.getByRole('button', { name: 'ログイン' }))
    
    expect(screen.getByText('メールアドレスは必須です')).toBeInTheDocument()
    expect(screen.getByText('パスワードは必須です')).toBeInTheDocument()
    expect(mockOnSubmit).not.toHaveBeenCalled()
  })

  it('異常系: 不正なメールアドレス形式', async () => {
    const user = userEvent.setup()
    
    render(<LoginForm onSubmit={mockOnSubmit} onError={mockOnError} />)
    
    await user.type(screen.getByLabelText('メールアドレス'), 'invalid-email')
    await user.type(screen.getByLabelText('パスワード'), 'password')
    await user.click(screen.getByRole('button', { name: 'ログイン' }))
    
    expect(screen.getByText('有効なメールアドレスを入力してください')).toBeInTheDocument()
    expect(mockOnSubmit).not.toHaveBeenCalled()
  })

  it('正常系: パスワード表示/非表示の切り替え', async () => {
    const user = userEvent.setup()
    
    render(<LoginForm onSubmit={mockOnSubmit} onError={mockOnError} />)
    
    const passwordInput = screen.getByLabelText('パスワード')
    const toggleButton = screen.getByRole('button', { name: 'パスワードを表示' })
    
    // 初期状態は非表示
    expect(passwordInput).toHaveAttribute('type', 'password')
    
    // 表示に切り替え
    await user.click(toggleButton)
    expect(passwordInput).toHaveAttribute('type', 'text')
    
    // 非表示に戻す
    await user.click(toggleButton)
    expect(passwordInput).toHaveAttribute('type', 'password')
  })

  it('正常系: ローディング状態の表示', () => {
    render(<LoginForm onSubmit={mockOnSubmit} onError={mockOnError} loading={true} />)
    
    const submitButton = screen.getByRole('button', { name: 'ログイン中...' })
    expect(submitButton).toBeDisabled()
    expect(screen.getByTestId('loading-spinner')).toBeInTheDocument()
  })

  it('正常系: エラーメッセージの表示', () => {
    const errorMessage = '認証に失敗しました'
    
    render(
      <LoginForm 
        onSubmit={mockOnSubmit} 
        onError={mockOnError} 
        error={errorMessage} 
      />
    )
    
    expect(screen.getByText(errorMessage)).toBeInTheDocument()
    expect(screen.getByRole('alert')).toBeInTheDocument()
  })
})
```

---

## 5. バリデーション・ユーティリティテスト

### 5.1 バリデーション関数テスト

#### src/utils/__tests__/validation.test.ts
```typescript
import { describe, it, expect } from 'vitest'
import {
  validateEmail,
  validatePassword,
  validateSkillLevel,
  validateRequired,
  validateLength,
  validateDate
} from '../validation'

describe('バリデーション関数', () => {
  describe('validateEmail', () => {
    it('正常系: 有効なメールアドレス', () => {
      const validEmails = [
        'user@example.com',
        'test.user@domain.co.jp',
        'user+tag@example.org',
        'user123@test-domain.com'
      ]
      
      validEmails.forEach(email => {
        expect(validateEmail(email)).toBe(true)
      })
    })

    it('異常系: 無効なメールアドレス', () => {
      const invalidEmails = [
        'invalid-email',
        '@example.com',
        'user@',
        'user..name@example.com',
        'user@.com',
        ''
      ]
      
      invalidEmails.forEach(email => {
        expect(validateEmail(email)).toBe(false)
      })
    })
  })

  describe('validatePassword', () => {
    it('正常系: 有効なパスワード', () => {
      const validPasswords = [
        'Password123!',
        'MySecure@Pass1',
        'Test#Password2024'
      ]
      
      validPasswords.forEach(password => {
        expect(validatePassword(password)).toBe(true)
      })
    })

    it('異常系: 無効なパスワード', () => {
      const invalidPasswords = [
        'short',           // 短すぎる
        'password',        // 大文字なし
        'PASSWORD',        // 小文字なし
        'Password',        // 数字なし
        'Password123',     // 特殊文字なし
        ''
      ]
      
      invalidPasswords.forEach(password => {
        expect(validatePassword(password)).toBe(false)
      })
    })
  })

  describe('validateSkillLevel', () => {
    it('正常系: 有効なスキルレベル', () => {
      const validLevels = ['×', '△', '○', '◎']
      
      validLevels.forEach(level => {
        expect(validateSkillLevel(level)).toBe(true)
      })
    })

    it('異常系: 無効なスキルレベル', () => {
      const invalidLevels = ['A', 'B', 'C', '1', '2', '', null, undefined]
      
      invalidLevels.forEach(level => {
        expect(validateSkillLevel(level)).toBe(false)
      })
    })
  })

  describe('validateRequired', () => {
    it('正常系: 値が存在する', () => {
      expect(validateRequired('test')).toBe(true)
      expect(validateRequired('0')).toBe(true)
      expect(validateRequired(0)).toBe(true)
      expect(validateRequired(false)).toBe(true)
    })

    it('異常系: 値が存在しない', () => {
      expect(validateRequired('')).toBe(false)
      expect(validateRequired('   ')).toBe(false)
      expect(validateRequired(null)).toBe(false)
      expect(validateRequired(undefined)).toBe(false)
    })
  })

  describe('validateLength', () => {
    it('正常系: 長さが範囲内', () => {
      expect(validateLength('test', 1, 10)).toBe(true)
      expect(validateLength('hello', 5, 5)).toBe(true)
      expect(validateLength('', 0, 5)).toBe(true)
    })

    it('異常系: 長さが範囲外', () => {
      expect(validateLength('test', 5, 10)).toBe(false)
      expect(validateLength('very long text', 1, 5)).toBe(false)
    })
  })

  describe('validateDate', () => {
    it('正常系: 有効な日付形式', () => {
      expect(validateDate('2025-05-29')).toBe(true)
      expect(validateDate('2024-12-31')).toBe(true)
      expect(validateDate('2020-01-01')).toBe(true)
    })

    it('異常系: 無効な日付形式', () => {
      expect(validateDate('2025/05/29')).toBe(false)
      expect(validateDate('29-05-2025')).toBe(false)
      expect(validateDate('invalid-date')).toBe(false)
      expect(validateDate('')).toBe(false)
    })
  })
})
```

### 5.2 ユーティリティ関数テスト

#### src/utils/__tests__/formatters.test.ts
```typescript
import { describe, it, expect } from 'vitest'
import {
  formatDate,
  formatSkillLevel,
  formatExperience,
  formatFileSize,
  formatCurrency
} from '../formatters'

describe('フォーマッター関数', () => {
  describe('formatDate', () => {
    it('正常系: 日付文字列のフォーマット', () => {
      expect(formatDate('2025-05-29')).toBe('2025年5月29日')
      expect(formatDate('2024-12-01')).toBe('2024年12月1日')
    })

    it('正常系: Dateオブジェクトのフォーマット', () => {
      const date = new Date('2025-05-29')
      expect(formatDate(date)).toBe('2025年5月29日')
    })

    it('異常系: 無効な日付', () => {
      expect(formatDate('invalid-date')).toBe('無効な日付')
      expect(formatDate('')).toBe('無効な日付')
    })
  })

  describe('formatSkillLevel', () => {
    it('正常系: スキルレベルの表示名変換', () => {
      expect(formatSkillLevel('×')).toBe('未経験')
      expect(formatSkillLevel('△')).toBe('基礎')
      expect(formatSkillLevel('○')).toBe('実務')
      expect(formatSkillLevel('◎')).toBe('エキスパート')
    })

    it('異常系: 無効なスキルレベル', () => {
      expect(formatSkillLevel('invalid')).toBe('不明')
      expect(formatSkillLevel('')).toBe('不明')
      expect(formatSkillLevel(null)).toBe('不明')
    })
  })

  describe('formatExperience', () => {
    it('正常系: 経験年数のフォーマット', () => {
      expect(formatExperience(1)).toBe('1年')
      expect(formatExperience(3.5)).toBe('3年6ヶ月')
      expect(formatExperience(0.5)).toBe('6ヶ月')
    })

    it('境界値: 0年の場合', () => {
      expect(formatExperience(0)).toBe('未経験')
    })

    it('異常系: 負の値', () => {
      expect(formatExperience(-1)).toBe('未経験')
    })
  })

  describe('formatFileSize', () => {
    it('正常系: ファイルサイズのフォーマット', () => {
      expect(formatFileSize(1024)).toBe('1.0 KB')
      expect(formatFileSize(1048576)).toBe('1.0 MB')
      expect(formatFileSize(1073741824)).toBe('1.0 GB')
    })

    it('境界値: 0バイト', () => {
      expect(formatFileSize(0)).toBe('0 B')
    })
  })

  describe('formatCurrency', () => {
    it('正常系: 通貨フォーマット', () => {
      expect(formatCurrency(1000)).toBe('¥1,000')
      expect(formatCurrency(1234567)).toBe('¥1,234,567')
    })

    it('境界値: 0円', () => {
      expect(formatCurrency(0)).toBe('¥0')
    })
  })
})
```

---

## 6. カスタムフック・状態管理テスト

### 6.1 認証フックテスト

#### src/hooks/__tests__/useAuth.test.ts
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { renderHook, act, waitFor } from '@testing-library/react'
import { useAuth } from '../useAuth'
import { AuthProvider } from '@/contexts/AuthContext'
import { ReactNode } from 'react'

// テスト用ラッパー
const wrapper = ({ children }: { children: ReactNode }) => (
  <AuthProvider>{children}</AuthProvider>
)

describe('useAuth', () => {
  beforeEach(() => {
    localStorage.clear()
    vi.clearAllMocks()
  })

  it('正常系: 初期状態の確認', () => {
    const { result } = renderHook(() => useAuth(), { wrapper })
    
    expect(result.current.user).toBeNull()
    expect(result.current.isAuthenticated).toBe(false)
    expect(result.current.loading).toBe(false)
  })

  it('正常系: ログイン成功', async () => {
    const { result } = renderHook(() => useAuth(), { wrapper })
    
    await act(async () => {
      await result.current.login('user@example.com', 'password')
    })
    
    await waitFor(() => {
      expect(result.current.isAuthenticated).toBe(true)
      expect(result.current.user).toEqual({
        id: 1,
        name: 'テストユーザー',
        email: 'user@example.com',
        role: 'user'
      })
    })
  })

  it('異常系: ログイン失敗', async () => {
    const { result } = renderHook(() => useAuth(), { wrapper })
    
    await act(async () => {
      try {
        await result.current.login('user@example.com', 'wrongpassword')
      } catch (error) {
        expect(error.message).toBe('認証に失敗しました')
      }
    })
    
    expect(result.current.isAuthenticated).toBe(false)
    expect(result.current.user).toBeNull()
  })

  it('正常系: ログアウト', async () => {
    const { result } = renderHook(() => useAuth(), { wrapper })
    
    // 先にログイン
    await act(async () => {
      await result.current.login('user@example.com', 'password')
    })
    
    // ログアウト
    await act(async () => {
      await result.current.logout()
    })
    
    expect(result.current.isAuthenticated).toBe(false)
    expect(result.current.user).toBeNull()
  })

  it('正常系: トークン自動復元', async () => {
    // 事前にトークンを設定
    localStorage.setItem('token', 'valid-token')
    
    const { result } = renderHook(() => useAuth(), { wrapper })
    
    await waitFor(() => {
      expect(result.current.isAuthenticated).toBe(true)
    })
  })
})
```

### 6.2 スキル管理フックテスト

#### src/hooks/__tests__/useSkills.test.ts
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { renderHook, act, waitFor } from '@testing-library/react'
import { useSkills } from '../useSkills'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { ReactNode } from 'react'

describe('useSkills', () => {
  let queryClient: QueryClient

  const wrapper = ({ children }: { children: ReactNode }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  )

  beforeEach(() => {
    queryClient = new QueryClient({
      defaultOptions: {
        queries: { retry: false },
        mutations: { retry: false }
      }
    })
  })

  it('正常系: スキル一覧取得', async () => {
    const { result } = renderHook(() => useSkills(), { wrapper })
    
    await waitFor(() => {
      expect(result.current.isLoading).toBe(false)
    })
    
    expect(result.current.skills).toHaveLength(2)
    expect(result.current.skills[0]).toEqual({
      id: 1,
      name: 'JavaScript',
      category: 'プログラミング言語',
      level: '○',
      experience: '3年'
    })
  })

  it('正常系: スキル追加', async () => {
    const { result } = renderHook(() => useSkills(), { wrapper })
    
    const newSkill = {
      name: 'Python',
      category: 'プログラミング言語',
      level: '△' as const
    }
    
    await act(async () => {
      await result.current.addSkill.mutateAsync(newSkill)
    })
    
    expect(result.current.addSkill.isSuccess).toBe(true)
  })

  it('正常系: スキル更新', async () => {
    const { result } = renderHook(() => useSkills(), { wrapper })
    
    const updatedSkill = {
      id: 1,
      name: 'JavaScript',
      category: 'プログラミング言語',
      level: '◎' as const
    }
    
    await act(async () => {
      await result.current.updateSkill.mutateAsync(updatedSkill)
    })
    
    expect(result.current.updateSkill.isSuccess).toBe(true)
  })

  it('正常系: スキル削除', async () => {
    const { result } = renderHook(() => useSkills(), { wrapper })
    
    await act(async () => {
      await result.current.deleteSkill.mutateAsync(1)
    })
    
    expect(result.current.deleteSkill.isSuccess).toBe(true)
  })

  it('正常系: スキルフィルタリング', async () => {
    const { result } = renderHook(() => useSkills('プログラミング言語'), { wrapper })
    
    await waitFor(() => {
      expect(result.current.isLoading).toBe(false)
    })
    
    expect(result.current.skills).toHaveLength(2)
    expect(result.current.skills.every(skill => 
      skill.category === 'プログラミング言語'
    )).toBe(true)
  })
})
```

### 6.3 フォーム状態管理テスト

#### src/hooks/__tests__/useForm.test.ts
```typescript
import { describe, it, expect, beforeEach } from 'vitest'
import { renderHook, act } from '@testing-library/react'
import { useForm } from '../useForm'

describe('useForm', () => {
  const initialValues = {
    name: '',
    email: '',
    level: '×' as const
  }

  const validationRules = {
    name: (value: string) => value.length > 0 ? null : '名前は必須です',
    email: (value: string) => /\S+@\S+\.\S+/.test(value) ? null : '有効なメールアドレスを入力してください',
    level: (value: string) => ['×', '△', '○', '◎'].includes(value) ? null : '有効なレベルを選択してください'
  }

  it('正常系: 初期状態の確認', () => {
    const { result } = renderHook(() => useForm(initialValues, validationRules))
    
    expect(result.current.values).toEqual(initialValues)
    expect(result.current.errors).toEqual({})
    expect(result.current.touched).toEqual({})
    expect(result.current.isValid).toBe(false)
  })

  it('正常系: 値の更新', () => {
    const { result } = renderHook(() => useForm(initialValues, validationRules))
    
    act(() => {
      result.current.setValue('name', 'テストユーザー')
    })
    
    expect(result.current.values.name).toBe('テストユーザー')
    expect(result.current.touched.name).toBe(true)
  })

  it('正常系: バリデーション実行', () => {
    const { result } = renderHook(() => useForm(initialValues, validationRules))
    
    act(() => {
      result.current.setValue('email', 'invalid-email')
    })
    
    expect(result.current.errors.email).toBe('有効なメールアドレスを入力してください')
    expect(result.current.isValid).toBe(false)
  })

  it('正常系: 有効なフォーム', () => {
    const { result } = renderHook(() => useForm(initialValues, validationRules))
    
    act(() => {
      result.current.setValue('name', 'テストユーザー')
      result.current.setValue('email', 'test@example.com')
      result.current.setValue('level', '○')
    })
    
    expect(result.current.isValid).toBe(true)
    expect(Object.keys(result.current.errors)).toHaveLength(0)
  })

  it('正常系: フォームリセット', () => {
    const { result } = renderHook(() => useForm(initialValues, validationRules))
    
    act(() => {
      result.current.setValue('name', 'テストユーザー')
      result.current.setValue('email', 'test@example.com')
    })
    
    act(() => {
      result.current.reset()
    })
    
    expect(result.current.values).toEqual(initialValues)
    expect(result.current.errors).toEqual({})
    expect(result.current.touched).toEqual({})
  })
})
```

---

## 7. エラーハンドリング・境界値テスト

### 7.1 エラーバウンダリテスト

#### src/components/__tests__/ErrorBoundary.test.tsx
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen } from '@testing-library/react'
import { ErrorBoundary } from '../ErrorBoundary'
import { ReactNode } from 'react'

// エラーを発生させるテスト用コンポーネント
const ThrowError = ({ shouldThrow }: { shouldThrow: boolean }) => {
  if (shouldThrow) {
    throw new Error('テストエラー')
  }
  return <div>正常なコンポーネント</div>
}

describe('ErrorBoundary', () => {
  beforeEach(() => {
    // console.error をモック化してエラーログを抑制
    vi.spyOn(console, 'error').mockImplementation(() => {})
  })

  it('正常系: エラーが発生しない場合は子コンポーネントを表示', () => {
    render(
      <ErrorBoundary>
        <ThrowError shouldThrow={false} />
      </ErrorBoundary>
    )
    
    expect(screen.getByText('正常なコンポーネント')).toBeInTheDocument()
  })

  it('異常系: エラーが発生した場合はエラー画面を表示', () => {
    render(
      <ErrorBoundary>
        <ThrowError shouldThrow={true} />
      </ErrorBoundary>
    )
    
    expect(screen.getByText('エラーが発生しました')).toBeInTheDocument()
    expect(screen.getByText('ページを再読み込みしてください')).toBeInTheDocument()
  })

  it('正常系: カスタムエラーメッセージの表示', () => {
    const customFallback = ({ error }: { error: Error }) => (
      <div>カスタムエラー: {error.message}</div>
    )
    
    render(
      <ErrorBoundary fallback={customFallback}>
        <ThrowError shouldThrow={true} />
      </ErrorBoundary>
    )
    
    expect(screen.getByText('カスタムエラー: テストエラー')).toBeInTheDocument()
  })

  it('正常系: エラーログの記録', () => {
    const mockOnError = vi.fn()
    
    render(
      <ErrorBoundary onError={mockOnError}>
        <ThrowError shouldThrow={true} />
      </ErrorBoundary>
    )
    
    expect(mockOnError).toHaveBeenCalledWith(
      expect.any(Error),
      expect.objectContaining({
        componentStack: expect.any(String)
      })
    )
  })
})
```

### 7.2 ネットワークエラーテスト

#### src/services/__tests__/ApiService.error.test.ts
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { ApiService } from '../ApiService'
import { server } from '@/test/mocks/server'
import { rest } from 'msw'

describe('ApiService - エラーハンドリング', () => {
  let apiService: ApiService

  beforeEach(() => {
    apiService = new ApiService()
  })

  it('異常系: ネットワークエラー', async () => {
    // ネットワークエラーをシミュレート
    server.use(
      rest.get('/api/skills', (req, res, ctx) => {
        return res.networkError('ネットワークに接続できません')
      })
    )

    await expect(apiService.getSkills()).rejects.toThrow('ネットワークエラーが発生しました')
  })

  it('異常系: 500 Internal Server Error', async () => {
    server.use(
      rest.get('/api/skills', (req, res, ctx) => {
        return res(
          ctx.status(500),
          ctx.json({ error: 'Internal Server Error' })
        )
      })
    )

    await expect(apiService.getSkills()).rejects.toThrow('サーバーエラーが発生しました')
  })

  it('異常系: 401 Unauthorized', async () => {
    server.use(
      rest.get('/api/skills', (req, res, ctx) => {
        return res(
          ctx.status(401),
          ctx.json({ error: 'Unauthorized' })
        )
      })
    )

    await expect(apiService.getSkills()).rejects.toThrow('認証が必要です')
  })

  it('異常系: 403 Forbidden', async () => {
    server.use(
      rest.get('/api/skills', (req, res, ctx) => {
        return res(
          ctx.status(403),
          ctx.json({ error: 'Forbidden' })
        )
      })
    )

    await expect(apiService.getSkills()).rejects.toThrow('アクセス権限がありません')
  })

  it('異常系: 404 Not Found', async () => {
    server.use(
      rest.get('/api/skills/999', (req, res, ctx) => {
        return res(
          ctx.status(404),
          ctx.json({ error: 'Not Found' })
        )
      })
    )

    await expect(apiService.getSkill(999)).rejects.toThrow('リソースが見つかりません')
  })

  it('異常系: タイムアウト', async () => {
    server.use(
      rest.get('/api/skills', (req, res, ctx) => {
        return res(ctx.delay(10000)) // 10秒遅延
      })
    )

    // タイムアウト設定（5秒）
    apiService.setTimeout(5000)

    await expect(apiService.getSkills()).rejects.toThrow('リクエストがタイムアウトしました')
  })

  it('正常系: リトライ機能', async () => {
    let callCount = 0
    
    server.use(
      rest.get('/api/skills', (req, res, ctx) => {
        callCount++
        if (callCount < 3) {
          return res(ctx.status(500))
        }
        return res(ctx.json([]))
      })
    )

    const result = await apiService.getSkillsWithRetry()
    
    expect(result).toEqual([])
    expect(callCount).toBe(3)
  })
})
```

### 7.3 境界値テスト

#### src/utils/__tests__/boundary.test.ts
```typescript
import { describe, it, expect } from 'vitest'
import { 
  calculateSkillScore,
  validateSkillInput,
  formatExperienceYears
} from '../skillUtils'

describe('境界値テスト', () => {
  describe('calculateSkillScore', () => {
    it('境界値: 空配列', () => {
      expect(calculateSkillScore([])).toBe(0)
    })

    it('境界値: 単一要素', () => {
      expect(calculateSkillScore([{ level: '◎', weight: 1 }])).toBe(4)
    })

    it('境界値: 最大値（全て◎）', () => {
      const skills = Array(100).fill({ level: '◎', weight: 1 })
      expect(calculateSkillScore(skills)).toBe(4)
    })

    it('境界値: 最小値（全て×）', () => {
      const skills = Array(100).fill({ level: '×', weight: 1 })
      expect(calculateSkillScore(skills)).toBe(1)
    })

    it('境界値: 重み0', () => {
      expect(calculateSkillScore([{ level: '◎', weight: 0 }])).toBe(0)
    })

    it('境界値: 重み最大値', () => {
      expect(calculateSkillScore([{ level: '◎', weight: Number.MAX_SAFE_INTEGER }])).toBe(4)
    })
  })

  describe('validateSkillInput', () => {
    it('境界値: 最小文字数（1文字）', () => {
      expect(validateSkillInput('A')).toBe(true)
    })

    it('境界値: 最大文字数（100文字）', () => {
      const longName = 'A'.repeat(100)
      expect(validateSkillInput(longName)).toBe(true)
    })

    it('境界値: 文字数超過（101文字）', () => {
      const tooLongName = 'A'.repeat(101)
      expect(validateSkillInput(tooLongName)).toBe(false)
    })

    it('境界値: 空文字', () => {
      expect(validateSkillInput('')).toBe(false)
    })

    it('境界値: 空白のみ', () => {
      expect(validateSkillInput('   ')).toBe(false)
    })

    it('境界値: 特殊文字', () => {
      expect(validateSkillInput('C++')).toBe(true)
      expect(validateSkillInput('.NET')).toBe(true)
      expect(validateSkillInput('Node.js')).toBe(true)
    })
  })

  describe('formatExperienceYears', () => {
    it('境界値: 0年', () => {
      expect(formatExperienceYears(0)).toBe('未経験')
    })

    it('境界値: 0.1年（1ヶ月強）', () => {
      expect(formatExperienceYears(0.1)).toBe('1ヶ月')
    })

    it('境界値: 0.5年（6ヶ月）', () => {
      expect(formatExperienceYears(0.5)).toBe('6ヶ月')
    })

    it('境界値: 1年', () => {
      expect(formatExperienceYears(1)).toBe('1年')
    })

    it('境界値: 1.5年', () => {
      expect(formatExperienceYears(1.5)).toBe('1年6ヶ月')
    })

    it('境界値: 10年', () => {
      expect(formatExperienceYears(10)).toBe('10年')
    })

    it('境界値: 負の値', () => {
      expect(formatExperienceYears(-1)).toBe('未経験')
    })

    it('境界値: 非数値', () => {
      expect(formatExperienceYears(NaN)).toBe('未経験')
      expect(formatExperienceYears(Infinity)).toBe('未経験')
    })
  })
})
```

---

## 8. パフォーマンス・メモリテスト

### 8.1 レンダリングパフォーマンステスト

#### src/components/__tests__/SkillList.performance.test.tsx
```typescript
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'
import { SkillList } from '../SkillList'
import { createMockSkill } from '@/test/factories'

describe('SkillList - パフォーマンステスト', () => {
  it('パフォーマンス: 大量データ（1000件）のレンダリング', () => {
    const largeSkillList = Array.from({ length: 1000 }, (_, index) => 
      createMockSkill({ id: index + 1, name: `Skill ${index + 1}` })
    )

    const startTime = performance.now()
    
    render(<SkillList skills={largeSkillList} />)
    
    const endTime = performance.now()
    const renderTime = endTime - startTime

    // レンダリング時間が100ms以内であることを確認
    expect(renderTime).toBeLessThan(100)
    
    // 仮想化により表示される要素数が制限されていることを確認
    const visibleItems = screen.getAllByTestId(/skill-item-/)
    expect(visibleItems.length).toBeLessThan(100) // 仮想化により制限
  })

  it('パフォーマンス: 頻繁な更新に対する最適化', () => {
    const skills = Array.from({ length: 100 }, (_, index) => 
      createMockSkill({ id: index + 1 })
    )

    const { rerender } = render(<SkillList skills={skills} />)

    // 複数回の再レンダリングを実行
    const startTime = performance.now()
    
    for (let i = 0; i < 10; i++) {
      const updatedSkills = skills.map(skill => ({
        ...skill,
        level: i % 2 === 0 ? '○' : '◎'
      }))
      rerender(<SkillList skills={updatedSkills} />)
    }
    
    const endTime = performance.now()
    const totalRerenderTime = endTime - startTime

    // 10回の再レンダリングが200ms以内であることを確認
    expect(totalRerenderTime).toBeLessThan(200)
  })

  it('パフォーマンス: メモ化の効果確認', () => {
    const skills = Array.from({ length: 50 }, (_, index) => 
      createMockSkill({ id: index + 1 })
    )

    const mockOnSkillClick = vi.fn()
    
    const { rerender } = render(
      <SkillList skills={skills} onSkillClick={mockOnSkillClick} />
    )

    // 同じpropsで再レンダリング（メモ化により最適化されるべき）
    const startTime = performance.now()
    
    for (let i = 0; i < 5; i++) {
      rerender(<SkillList skills={skills} onSkillClick={mockOnSkillClick} />)
    }
    
    const endTime = performance.now()
    const memoizedRerenderTime = endTime - startTime

    // メモ化により高速化されていることを確認
    expect(memoizedRerenderTime).toBeLessThan(50)
  })
})
```

### 8.2 メモリリークテスト

#### src/hooks/__tests__/useSkills.memory.test.ts
```typescript
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest'
import { renderHook, cleanup } from '@testing-library/react'
import { useSkills } from '../useSkills'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { ReactNode } from 'react'

describe('useSkills - メモリリークテスト', () => {
  let queryClient: QueryClient
  let initialMemory: number

  const wrapper = ({ children }: { children: ReactNode }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  )

  beforeEach(() => {
    queryClient = new QueryClient({
      defaultOptions: {
        queries: { retry: false },
        mutations: { retry: false }
      }
    })
    
    // ガベージコレクションを実行
    if (global.gc) {
      global.gc()
    }
    
    initialMemory = process.memoryUsage().heapUsed
  })

  afterEach(() => {
    cleanup()
    queryClient.clear()
  })

  it('メモリリーク: 大量のフック作成・破棄', () => {
    const hookInstances: any[] = []

    // 100個のフックインスタンスを作成
    for (let i = 0; i < 100; i++) {
      const { result, unmount } = renderHook(() => useSkills(), { wrapper })
      hookInstances.push({ result, unmount })
    }

    // すべてのフックをアンマウント
    hookInstances.forEach(({ unmount }) => unmount())

    // ガベージコレクションを実行
    if (global.gc) {
      global.gc()
    }

    const finalMemory = process.memoryUsage().heapUsed
    const memoryIncrease = finalMemory - initialMemory

    // メモリ増加が1MB以内であることを確認
    expect(memoryIncrease).toBeLessThan(1024 * 1024)
  })

  it('メモリリーク: イベントリスナーの適切なクリーンアップ', () => {
    const addEventListenerSpy = vi.spyOn(window, 'addEventListener')
    const removeEventListenerSpy = vi.spyOn(window, 'removeEventListener')

    const { unmount } = renderHook(() => useSkills(), { wrapper })

    const addedListeners = addEventListenerSpy.mock.calls.length

    unmount()

    const removedListeners = removeEventListenerSpy.mock.calls.length

    // 追加されたリスナーと削除されたリスナーの数が一致することを確認
    expect(removedListeners).toBe(addedListeners)

    addEventListenerSpy.mockRestore()
    removeEventListenerSpy.mockRestore()
  })
})
```

---

## 9. テストファクトリー・ヘルパー

### 9.1 テストデータファクトリー

#### src/test/factories/index.ts
```typescript
import { Skill, User, Profile } from '@/types'

export const createMockUser = (overrides: Partial<User> = {}): User => ({
  id: 1,
  name: 'テストユーザー',
  email: 'test@example.com',
  role: 'user',
  department: '開発部',
  position: 'エンジニア',
  joinDate: '2020-04-01',
  ...overrides
})

export const createMockSkill = (overrides: Partial<Skill> = {}): Skill => ({
  id: 1,
  name: 'JavaScript',
  category: 'プログラミング言語',
  level: '○',
  experience: '3年',
  description: 'Webアプリケーション開発',
  acquiredDate: '2020-01-01',
  ...overrides
})

export const createMockProfile = (overrides: Partial<Profile> = {}): Profile => ({
  id: 1,
  userId: 1,
  name: 'テストユーザー',
  email: 'test@example.com',
  department: '開発部',
  position: 'エンジニア',
  joinDate: '2020-04-01',
  bio: 'テスト用プロフィール',
  avatar: '/images/avatar.jpg',
  ...overrides
})

export const createMockSkillList = (count: number = 5): Skill[] => {
  return Array.from({ length: count }, (_, index) => 
    createMockSkill({
      id: index + 1,
      name: `Skill ${index + 1}`,
      level: ['×', '△', '○', '◎'][index % 4] as any
    })
  )
}
```

### 9.2 テストヘルパー関数

#### src/test/helpers/index.ts
```typescript
import { render, RenderOptions } from '@testing-library/react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { AuthProvider } from '@/contexts/AuthContext'
import { ReactElement, ReactNode } from 'react'

// テスト用プロバイダー
const createTestQueryClient = () => new QueryClient({
  defaultOptions: {
    queries: { retry: false },
    mutations: { retry: false }
  }
})

interface CustomRenderOptions extends Omit<RenderOptions, 'wrapper'> {
  queryClient?: QueryClient
  initialAuth?: any
}

// カスタムレンダー関数
export const renderWithProviders = (
  ui: ReactElement,
  {
    queryClient = createTestQueryClient(),
    initialAuth = null,
    ...renderOptions
  }: CustomRenderOptions = {}
) => {
  const Wrapper = ({ children }: { children: ReactNode }) => (
    <QueryClientProvider client={queryClient}>
      <AuthProvider initialValue={initialAuth}>
        {children}
      </AuthProvider>
    </QueryClientProvider>
  )

  return {
    ...render(ui, { wrapper: Wrapper, ...renderOptions }),
    queryClient
  }
}

// 非同期処理待機ヘルパー
export const waitForLoadingToFinish = () => {
  return new Promise(resolve => setTimeout(resolve, 0))
}

// フォーム入力ヘルパー
export const fillForm = async (user: any, formData: Record<string, string>) => {
  for (const [field, value] of Object.entries(formData)) {
    const input = screen.getByLabelText(new RegExp(field, 'i'))
    await user.clear(input)
    await user.type(input, value)
  }
}

// ローカルストレージモック
export const mockLocalStorage = () => {
  const store: Record<string, string> = {}
  
  return {
    getItem: vi.fn((key: string) => store[key] || null),
    setItem: vi.fn((key: string, value: string) => {
      store[key] = value
    }),
    removeItem: vi.fn((key: string) => {
      delete store[key]
    }),
    clear: vi.fn(() => {
      Object.keys(store).forEach(key => delete store[key])
    })
  }
}
```

---

## 10. CI/CD統合・レポート

### 10.1 GitHub Actions設定

#### .github/workflows/test.yml
```yaml
name: Test Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  unit-test:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run unit tests
        run: npm run test:coverage
        
      - name: Upload coverage reports
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/lcov.info
          flags: unittests
          name: codecov-umbrella
          
      - name: Comment PR with coverage
        if: github.event_name == 'pull_request'
        uses: romeovs/lcov-reporter-action@v0.3.1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          lcov-file: ./coverage/lcov.info
```

### 10.2 テストレポート設定

#### vitest.config.ts（レポート設定追加）
```typescript
export default defineConfig({
  // ... 既存設定
  test: {
    // ... 既存設定
    reporters: ['default', 'html', 'json'],
    outputFile: {
      html: './test-results/index.html',
      json: './test-results/results.json'
    }
  }
})
```

---

## 11. まとめ・ベストプラクティス

### 11.1 テスト作成のガイドライン

1. **AAA パターンの遵守**
   - Arrange（準備）: テストデータとモックの設定
   - Act（実行）: テスト対象の実行
   - Assert（検証）: 結果の検証

2. **テスト名の命名規則**
   - `[正常系|異常系|境界値]: [テストの内容]`
   - 具体的で理解しやすい名前を使用

3. **独立性の確保**
   - 各テストは他のテストに依存しない
   - beforeEach/afterEachでクリーンアップ

4. **適切なモック使用**
   - 外部依存は必ずモック化
   - 実装詳細ではなく、インターフェースをテスト

### 11.2 品質指標

- **カバレッジ目標**: 90%以上
- **テスト実行時間**: 全体で30秒以内
- **テスト安定性**: フレーキーテスト0%

### 11.3 継続的改善

- 週次でテスト結果レビュー
- カバレッジ低下時の即座対応
- 新機能追加時の必須テスト作成

---

**文書終了**

このユニットテスト実装ガイドに従って、高品質で保守性の高いテストコードを作成し、継続的な品質向上を実現してください。
