#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""SQLサンプルデータからPrisma用seed.tsを生成するスクリプト

スクリプトの目的:
    docs/design/database/data配下に存在する`*_sample_data.sql`ファイルを読み取り、
    Prisma Clientで利用できる`seed.ts`コードを生成する。

使用方法:
    python3 scripts/sql-to-seed-prisma-fixed.py <sql_dir> [output_file]
    output_file を省略した場合、"src/database/prisma/seed.ts" に生成します。

このスクリプトはテーブル名・カラム名をそのままsnake_caseで出力する。
"""

import sys
import re
from pathlib import Path
from typing import List, Tuple, Any


def to_model_name(name: str) -> str:
    """Convert table name like 'MST_Tenant' to Prisma model name 'Tenant'."""
    name = re.sub(r"^([A-Z]+_)", "", name)
    return re.sub(r"(?:^|_)([A-Za-z])", lambda m: m.group(1).upper(), name)


def to_prisma_property(name: str) -> str:
    """Return Prisma client property name (camelCase)."""
    model = to_model_name(name)
    return model[:1].lower() + model[1:]


def parse_sql_file(path: Path) -> Tuple[str, List[str], List[List[Any]]]:
    """INSERT文を含むSQLファイルを解析する"""
    content = path.read_text(encoding="utf-8")

    match = re.search(
        r"INSERT\s+INTO\s+(\w+)\s*\(([^)]*)\)\s*VALUES\s*(.*?);\s*$",
        content,
        re.S,
    )
    if not match:
        raise ValueError(f"INSERT文が見つかりません: {path}")

    table = match.group(1)
    columns = [c.strip() for c in match.group(2).split(',')]

    values_block = match.group(3)

    # 値のタプルを文字列として抽出 (クォート内の括弧を考慮)
    row_texts: List[str] = []
    buf: List[str] = []
    in_quote = False
    escape = False
    depth = 0
    for ch in values_block:
        if ch == "'" and not escape:
            in_quote = not in_quote
        if ch == "\\" and in_quote:
            escape = not escape
            buf.append(ch)
            continue
        else:
            escape = False

        if ch == '(' and not in_quote:
            if depth == 0:
                buf = []
            else:
                buf.append(ch)
            depth += 1
            continue
        if ch == ')' and not in_quote:
            depth -= 1
            if depth == 0:
                row_texts.append(''.join(buf).strip())
                continue
            else:
                buf.append(ch)
                continue

        if depth > 0:
            buf.append(ch)

    rows: List[List[Any]] = []
    for row_text in row_texts:
        fields: List[Any] = []
        for val in re.split(r",(?=(?:[^']*'[^']*')*[^']*$)", row_text):
            val = val.strip()
            if val.upper() == 'NULL':
                fields.append(None)
            elif val.upper() == 'TRUE':
                fields.append(True)
            elif val.upper() == 'FALSE':
                fields.append(False)
            else:
                if val.startswith("'") and val.endswith("'"):
                    fields.append(val[1:-1].replace("\\'", "'"))
                else:
                    fields.append(val)
        rows.append(fields)

    return table, columns, rows


def format_value(value: Any) -> str:
    """TypeScript用の値表現に変換"""
    if value is None:
        return 'null'
    if value is True:
        return 'true'
    if value is False:
        return 'false'
    if isinstance(value, str) and re.match(r"^-?\d+(\.\d+)?$", value):
        return value
    if isinstance(value, str):
        return f'"{value}"'
    return str(value)


def generate_ts(table: str, columns: List[str], rows: List[List[Any]]) -> str:
    """Prisma用のTypeScriptコードを生成"""
    lines: List[str] = []
    model_prop = to_prisma_property(table)
    lines.append(f"console.log('📊 {table}データを投入中...')")
    lines.append(f"await prisma.{model_prop}.createMany({{")
    lines.append('  data: [')
    for row in rows:
        lines.append('    {')
        for col, val in zip(columns, row):
            lines.append(f"      {col}: {format_value(val)},")
        lines.append('    },')
    lines.append('  ],')
    lines.append('})')
    return '\n'.join(lines)


def main(sql_dir: str, output_file: str) -> None:
    sql_path = Path(sql_dir)
    out_path = Path(output_file)

    snippets: List[str] = []
    for sql_file in sorted(sql_path.glob('*_sample_data.sql')):
        table, columns, rows = parse_sql_file(sql_file)
        snippet = generate_ts(table, columns, rows)
        snippets.append(f"// {sql_file.name}\n{snippet}\n")

    header = [
        '// Auto generated by sql-to-seed-prisma-fixed.py',
        "import { PrismaClient } from '@prisma/client'",
        '',
        'const prisma = new PrismaClient()',
        '',
        'export async function runSampleSeed() {',
        "  console.log('🌱 データベースの初期データ投入を開始します...')",
    ]
    footer = [
        "  console.log('✅ 初期データ投入が完了しました！')",
        '}',
        '',
        'if (require.main === module) {',
        '  runSampleSeed().then(() => prisma.$disconnect())',
        '}',
    ]

    # Ensure output directory exists
    out_path.parent.mkdir(parents=True, exist_ok=True)

    with out_path.open('w', encoding='utf-8') as f:
        f.write('\n'.join(header) + '\n')
        for snippet in snippets:
            f.write('  ' + snippet.replace('\n', '\n  ') + '\n')
        f.write('\n'.join(footer) + '\n')


if __name__ == '__main__':
    if len(sys.argv) not in (2, 3):
        print('Usage: python sql-to-seed-prisma-fixed.py <sql_dir> [output_file]')
        sys.exit(1)
    sql_dir = sys.argv[1]
    out_file = sys.argv[2] if len(sys.argv) == 3 else 'src/database/prisma/seed.ts'
    main(sql_dir, out_file)
